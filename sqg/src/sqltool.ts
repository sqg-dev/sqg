import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { homedir } from "node:os";
import { basename, dirname, extname, join, resolve } from "node:path";
import consola, { LogLevels } from "consola";
import Handlebars from "handlebars";
import YAML from "yaml";
import { z } from "zod";
import {
  DB_ENGINES,
  type DbEngine,
  findSimilarGenerators,
  GENERATOR_NAMES,
  getGeneratorEngine,
  isValidGenerator,
  parseGenerator,
  SHORT_GENERATOR_NAMES,
} from "./constants.js";
import { getDatabaseEngine } from "./db/index.js";
import {
  ConfigError,
  type ErrorContext,
  FileNotFoundError,
  InvalidGeneratorError,
  SqgError,
} from "./errors.js";
import { type Generator, getGenerator } from "./generators/index.js";
import type { ColumnInfo, SQLQuery, TableInfo } from "./sql-query.js";
import { parseSQLQueries, StructType } from "./sql-query.js";
import type { TypeMapper } from "./type-mapping.js";

export const GENERATED_FILE_COMMENT =
  "This file is generated by SQG (https://sqg.dev). Do not edit manually.";

const configSchema = z.object({
  result: z.record(z.string(), z.string()).optional(),
});

export class Config {
  constructor(public result: Map<string, ColumnInfo>) {}

  getColumnInfo(name: string): ColumnInfo | undefined {
    return this.result.get(name);
  }

  static fromYaml(name: string, filePath: string, configStr: string): Config {
    //consola.info("Config:", config);
    let configObj: unknown;
    try {
      configObj = YAML.parse(configStr);
      //consola.info("Config object:", configObj);
    } catch (e) {
      throw new Error(
        `Error parsing YAML config for query ${name} in ${filePath}: \n${configStr}\n ${e}`,
      );
    }
    const result = configSchema.safeParse(configObj);
    if (!result.success) {
      throw new Error(
        `Error parsing config for query ${name} in ${filePath}: \n${configStr}\n ${result.error}`,
      );
    }

    const columnMap = new Map<string, ColumnInfo>();
    for (const [name, info] of Object.entries(result.data.result ?? {})) {
      const parts = info
        .trim()
        .split(" ")
        .map((part) => part.trim());
      let type: string;
      let nullable = true;
      if (parts.length === 1) {
        type = parts[0];
      } else if (parts.length === 2) {
        type = parts[0];
        if (parts[1].toLocaleLowerCase() !== "null") {
          throw new Error(
            `Invalid config for column ${name} in ${filePath}: \n${configStr}\n ${info}`,
          );
        }
        nullable = true;
      } else if (parts.length === 3) {
        type = parts[0];
        if (parts[1].toLocaleLowerCase() !== "not" || parts[2].toLocaleLowerCase() !== "null") {
          throw new Error(
            `Invalid config for column ${name} in ${filePath}: \n${configStr}\n ${info}`,
          );
        }
        nullable = false;
      } else {
        throw new Error(
          `Invalid config for column ${name} in ${filePath}: \n${configStr}\n ${info}`,
        );
      }
      columnMap.set(name, {
        name,
        type,
        nullable,
      });
    }
    return new Config(columnMap);
  }
}

export type ParameterEntry = {
  name: string;
  value: string;
};

export type SqlQueryPart = string | ParameterEntry;

export type SqlQueryStatement = {
  sql: string; // for backwards compatibility, use sqlParts instead

  sqlParts: SqlQueryPart[];

  parameters: ParameterEntry[];
};

/** Util class to help generating a query with a given generator */
export class SqlQueryHelper {
  constructor(
    public query: SQLQuery,
    public generator: Generator,
    public statement: SqlQueryStatement,
  ) {}

  get id(): string {
    return this.query.id;
  }

  get isQuery(): boolean {
    return this.query.isQuery;
  }

  get isExec(): boolean {
    return this.query.isExec;
  }

  get isMigrate(): boolean {
    return this.query.isMigrate;
  }

  get isPluck(): boolean {
    return this.query.isPluck;
  }

  get isOne(): boolean {
    return this.query.isOne;
  }

  get parameterNames(): string[] {
    return this.statement.parameters.map((param) => param.name);
  }

  get skipGenerateFunction(): boolean {
    return this.query.skipGenerateFunction;
  }

  get parameters(): { name: string; type: string }[] {
    const vars = new Map(this.variables.map((param) => [param.name, param.type]));
    return this.statement.parameters.map((param) => ({
      name: param.name,
      type: vars.get(param.name)!,
    }));
  }

  get columns(): ColumnInfo[] {
    if (!(this.query.allColumns.type instanceof StructType)) {
      throw new Error(`Expected StructType ${this.query.allColumns.type}`);
    }
    return (this.query.allColumns.type as StructType).fields;
  }

  get variables(): { name: string; type: string }[] {
    return Array.from(this.query.variables.entries()).map(([name, value]) => ({
      name,
      type: this.generator.mapParameterType(
        this.query.parameterTypes?.get(name) ?? detectParameterType(value),
        false,
      ),
    }));
  }

  get sqlQuery(): string {
    return this.statement.sql;
  }

  get sqlQueryParts(): SqlQueryPart[] {
    return this.statement.sqlParts;
  }

  private get rowTypeStr(): string {
    return this.generator.rowType(this.query);
  }

  get functionReturnType(): string | Handlebars.SafeString {
    return new Handlebars.SafeString(this.generator.functionReturnType(this.query));
  }

  get rowType(): Handlebars.SafeString {
    return new Handlebars.SafeString(this.rowTypeStr);
  }

  get functionName(): string {
    return this.generator.getFunctionName(this.query.id);
  }

  get typeMapper(): TypeMapper {
    return this.generator.typeMapper;
  }
}

/** Util class to help generating appenders for tables */
export class TableHelper {
  constructor(
    public table: TableInfo,
    public generator: Generator,
  ) {}

  get id(): string {
    return this.table.id;
  }

  get tableName(): string {
    return this.table.tableName;
  }

  get columns(): ColumnInfo[] {
    // Filter columns if includeColumns is specified
    if (this.table.includeColumns.length > 0) {
      return this.table.columns.filter((c) => this.table.includeColumns.includes(c.name));
    }
    return this.table.columns;
  }

  get skipGenerateFunction(): boolean {
    return this.table.skipGenerateFunction;
  }

  get functionName(): string {
    return this.generator.getFunctionName(`create_${this.table.id}_appender`);
  }

  get className(): string {
    return this.generator.getClassName(`${this.table.id}_appender`);
  }

  get rowTypeName(): string {
    return this.generator.getClassName(`${this.table.id}_row`);
  }

  get typeMapper(): TypeMapper {
    return this.generator.typeMapper;
  }
}

function generateSourceFile(
  name: string,
  queries: SQLQuery[],
  tables: TableInfo[],
  templatePath: string,
  generator: Generator,
  engine: DbEngine,
  projectName: string,
  config?: any,
): string {
  const templateSrc = readFileSync(templatePath, "utf-8");

  const template = Handlebars.compile(templateSrc);
  Handlebars.registerHelper("mapType", (column: ColumnInfo) => generator.mapType(column));
  Handlebars.registerHelper("plusOne", (value: number) => value + 1);

  const migrations = queries
    .filter((q) => q.isMigrate)
    .map((q) => new SqlQueryHelper(q, generator, generator.getStatement(q)));

  // Create table helpers for appender generation (only for generators that support appenders)
  const tableHelpers = generator.supportsAppenders(engine)
    ? tables.filter((t) => !t.skipGenerateFunction).map((t) => new TableHelper(t, generator))
    : [];

  const result = template(
    {
      generatedComment: GENERATED_FILE_COMMENT,
      migrations,
      queries: queries.map((q) => new SqlQueryHelper(q, generator, generator.getStatement(q))),
      tables: tableHelpers,
      className: generator.getClassName(name),
      projectName,
      config,
    },
    {
      allowProtoPropertiesByDefault: true,
      allowProtoMethodsByDefault: true,
    },
  );

  return result;
}

/** All valid generator strings for schema validation */
const validGenerators = [...SHORT_GENERATOR_NAMES, ...GENERATOR_NAMES] as const;

/**
 * Project configuration schema with descriptions for validation messages
 */
const ProjectSchema = z.object({
  version: z.number().describe("Configuration version (currently 1)"),
  name: z
    .string()
    .min(1, "Project name is required")
    .describe("Project name used for generated class names"),
  sql: z
    .array(
      z.object({
        files: z
          .array(z.string().min(1))
          .min(1, "At least one SQL file is required")
          .describe("SQL files to process"),
        gen: z
          .array(
            z.object({
              generator: z
                .string()
                .refine((val) => isValidGenerator(val), {
                  message: `Invalid generator. Valid generators: ${validGenerators.join(", ")}`,
                })
                .describe(`Code generation generator: ${SHORT_GENERATOR_NAMES.join(", ")}`),
              name: z.string().optional().describe("Override the generated class/module name"),
              template: z.string().optional().describe("Custom Handlebars template path"),
              output: z
                .string()
                .min(1, "Output path is required")
                .describe("Output file or directory path"),
              config: z.any().optional().describe("Generator-specific configuration"),
            }),
          )
          .min(1, "At least one generator is required")
          .describe("Code generators to run"),
      }),
    )
    .min(1, "At least one SQL configuration is required")
    .describe("SQL file configurations"),
  sources: z
    .array(
      z.object({
        path: z.string().describe("Path to source file (supports $HOME)"),
        name: z.string().optional().describe("Variable name override"),
      }),
    )
    .optional()
    .describe("External source files to include as variables"),
});

export type Project = z.infer<typeof ProjectSchema>;
type Source = NonNullable<z.infer<typeof ProjectSchema.shape.sources>>[number];

export class ExtraVariable {
  constructor(
    public name: string,
    public value: string,
  ) {}
}

export function createExtraVariables(sources: Source[], suppressLogging = false): ExtraVariable[] {
  return sources.map((source) => {
    const path = source.path;
    const resolvedPath = path.replace("$HOME", homedir());
    const name = source.name ?? basename(path, extname(resolvedPath));
    const varName = `sources_${name.replace(/\s+/g, "_")}`;
    if (!suppressLogging) {
      consola.info("Extra variable:", varName, resolvedPath);
    }
    return new ExtraVariable(varName, `'${resolvedPath}'`);
  });
}

/**
 * Build a Project object from CLI options
 */
export interface CliProjectOptions {
  generator: string;
  files: string[];
  output?: string;
  name?: string;
}

export function buildProjectFromCliOptions(options: CliProjectOptions): Project {
  // Validate generator
  if (!isValidGenerator(options.generator)) {
    const similar = findSimilarGenerators(options.generator);
    const allGenerators = [...SHORT_GENERATOR_NAMES, ...GENERATOR_NAMES];
    throw new InvalidGeneratorError(
      options.generator,
      allGenerators,
      similar.length > 0 ? similar[0] : undefined,
    );
  }

  const generatorInfo = parseGenerator(options.generator);

  const genConfig: Project["sql"][0]["gen"][0] = {
    generator: options.generator,
    output: options.output || ".", // Placeholder for stdout - not used when writeToStdout is true
  };

  // Add config for Java generators (package name)
  if (generatorInfo.language === "java") {
    genConfig.config = {
      package: "generated",
    };
  }

  const project: Project = {
    version: 1,
    name: options.name || "generated",
    sql: [
      {
        files: options.files,
        gen: [genConfig],
      },
    ],
  };

  return project;
}

/**
 * Parse and validate project configuration with helpful error messages
 */
export function parseProjectConfig(filePath: string): Project {
  if (!existsSync(filePath)) {
    throw new FileNotFoundError(filePath, process.cwd());
  }

  let content: string;
  try {
    content = readFileSync(filePath, "utf-8");
  } catch (e) {
    throw new SqgError(
      `Cannot read config file: ${filePath}`,
      "CONFIG_PARSE_ERROR",
      "Check file permissions and that the path is correct",
    );
  }

  let parsed: unknown;
  try {
    parsed = YAML.parse(content);
  } catch (e) {
    const yamlError = e as Error;
    throw new SqgError(
      `Invalid YAML syntax in ${filePath}: ${yamlError.message}`,
      "CONFIG_PARSE_ERROR",
      "Check YAML syntax - common issues: incorrect indentation, missing colons, unquoted special characters",
    );
  }

  // Pre-validate to give better error messages for common mistakes
  if (parsed && typeof parsed === "object") {
    const obj = parsed as Record<string, unknown>;

    // Check for invalid generators before Zod validation
    if (obj.sql && Array.isArray(obj.sql)) {
      for (let i = 0; i < obj.sql.length; i++) {
        const sqlConfig = obj.sql[i] as Record<string, unknown>;

        // Check for invalid generators
        if (sqlConfig.gen && Array.isArray(sqlConfig.gen)) {
          for (let j = 0; j < sqlConfig.gen.length; j++) {
            const genConfig = sqlConfig.gen[j] as Record<string, unknown>;
            if (genConfig.generator && !isValidGenerator(String(genConfig.generator))) {
              const similar = findSimilarGenerators(String(genConfig.generator));
              const allGenerators = [...SHORT_GENERATOR_NAMES, ...GENERATOR_NAMES];
              throw new InvalidGeneratorError(
                String(genConfig.generator),
                allGenerators,
                similar.length > 0 ? similar[0] : undefined,
              );
            }
          }
        }
      }
    }
  }

  const result = ProjectSchema.safeParse(parsed);
  if (!result.success) {
    const prettyError = z.prettifyError(result.error);
    throw new ConfigError(
      `Configuration error in ${filePath}:\n${prettyError}`,
      "Check the configuration format against the documentation at https://sqg.dev",
      { file: filePath },
    );
  }

  return result.data;
}

function detectParameterType(value: string): string {
  const num = Number(value);
  if (!Number.isNaN(num)) {
    if (Number.isInteger(num)) {
      return "INTEGER";
    }
    return "REAL";
  }
  if (value.toLowerCase() === "true" || value.toLowerCase() === "false") {
    return "BOOLEAN";
  }
  return "TEXT";
}

export interface GeneratorConfig {
  generator: string;
  output: string;
  template?: string;
  config?: any;
  name?: string;
  projectName?: string;
}

export function getOutputPath(
  projectDir: string,
  sqlFileName: string,
  gen: { generator: string; output: string },
  generator: Generator,
) {
  const pathParts: string[] = [];
  if (!gen.output.startsWith("/")) {
    pathParts.push(projectDir);
  }
  if (gen.output.endsWith("/")) {
    const name = generator.getFilename(sqlFileName);
    pathParts.push(gen.output, name);
  } else {
    pathParts.push(gen.output);
  }
  const outputPath = join(...pathParts);
  mkdirSync(dirname(outputPath), { recursive: true });
  return outputPath;
}

export function validateQueries(queries: SQLQuery[]) {
  for (const query of queries) {
    if (query.isQuery && query.isPluck && query.columns.length !== 1) {
      throw SqgError.inQuery(
        `':pluck' modifier requires exactly 1 column, but query has ${query.columns.length} columns`,
        "VALIDATION_ERROR",
        query.id,
        query.filename,
        {
          suggestion:
            query.columns.length === 0
              ? "Ensure the query returns at least one column"
              : `Remove ':pluck' or select only one column. Current columns: ${query.columns.map((c) => c.name).join(", ")}`,
        },
      );
    }
    const columns = query.columns.map((col) => {
      const configColumn = query.config?.getColumnInfo(col.name);
      if (configColumn) {
        return configColumn;
      }
      return col;
    });
    query.allColumns = {
      name: query.id,
      nullable: false,
      type: new StructType(columns),
    };
  }
}

export async function writeGeneratedFile(
  projectDir: string,
  gen: GeneratorConfig,
  generator: Generator,
  file: string,
  queries: SQLQuery[],
  tables: TableInfo[],
  engine: DbEngine,
  writeToStdout = false,
): Promise<string | null> {
  await generator.beforeGenerate(projectDir, gen, queries, tables);
  const templateDir = dirname(new URL(import.meta.url).pathname);
  const templatePath = join(templateDir, gen.template ?? generator.template);
  const name = gen.name ?? basename(file, extname(file));
  const projectName = gen.projectName ?? name;
  const sourceFile = generateSourceFile(
    name,
    queries,
    tables,
    templatePath,
    generator,
    engine,
    projectName,
    gen.config,
  );

  if (writeToStdout) {
    // Write directly to stdout for better control
    process.stdout.write(sourceFile);
    if (!sourceFile.endsWith("\n")) {
      process.stdout.write("\n");
    }
    // Skip afterGenerate for stdout - it's only for file formatting
    return null;
  }

  const outputPath = getOutputPath(projectDir, name, gen, generator);
  writeFileSync(outputPath, sourceFile);
  consola.success(`Generated ${outputPath}`);
  await generator.afterGenerate(outputPath);
  return outputPath;
}

/**
 * Validation result for pre-flight checks
 */
export interface ValidationResult {
  valid: boolean;
  project?: {
    name: string;
    version: number;
  };
  sqlFiles?: string[];
  generators?: string[];
  errors?: Array<{
    code: string;
    message: string;
    suggestion?: string;
    context?: ErrorContext;
  }>;
}

/**
 * Validate project configuration from a Project object without executing queries
 * Use this for pre-flight checks before generation
 */
export async function validateProjectFromConfig(
  project: Project,
  projectDir: string,
): Promise<ValidationResult> {
  const errors: ValidationResult["errors"] = [];

  const sqlFiles: string[] = [];
  const generators: string[] = [];

  // Validate each SQL configuration
  for (const sql of project.sql) {
    for (const sqlFile of sql.files) {
      const fullPath = join(projectDir, sqlFile);
      sqlFiles.push(sqlFile);

      // Check SQL file exists
      if (!existsSync(fullPath)) {
        errors.push({
          code: "FILE_NOT_FOUND",
          message: `SQL file not found: ${sqlFile}`,
          suggestion: `Check that ${sqlFile} exists relative to ${projectDir}`,
          context: { file: fullPath },
        });
      }

      // Validate generators
      for (const gen of sql.gen) {
        generators.push(gen.generator);

        if (!isValidGenerator(gen.generator)) {
          const similar = findSimilarGenerators(gen.generator);
          errors.push({
            code: "INVALID_GENERATOR",
            message: `Invalid generator '${gen.generator}'`,
            suggestion:
              similar.length > 0
                ? `Did you mean '${similar[0]}'?`
                : `Valid generators: ${SHORT_GENERATOR_NAMES.join(", ")}`,
            context: { generator: gen.generator },
          });
        }
      }
    }
  }

  return {
    valid: errors.length === 0,
    project: {
      name: project.name,
      version: project.version,
    },
    sqlFiles: [...new Set(sqlFiles)],
    generators: [...new Set(generators)],
    errors: errors.length > 0 ? errors : undefined,
  };
}

/**
 * Validate project configuration from a YAML file without executing queries
 * Use this for pre-flight checks before generation
 */
export async function validateProject(projectPath: string): Promise<ValidationResult> {
  const projectDir = resolve(dirname(projectPath));

  // Parse and validate config
  let project: Project;
  try {
    project = parseProjectConfig(projectPath);
  } catch (e) {
    if (e instanceof SqgError) {
      return {
        valid: false,
        errors: [
          {
            code: e.code,
            message: e.message,
            suggestion: e.suggestion,
            context: e.context,
          },
        ],
      };
    }
    return {
      valid: false,
      errors: [{ code: "UNKNOWN_ERROR", message: String(e) }],
    };
  }

  return await validateProjectFromConfig(project, projectDir);
}

/**
 * Process a project configuration and generate code from a Project object
 */
export async function processProjectFromConfig(
  project: Project,
  projectDir: string,
  writeToStdout = false,
): Promise<string[]> {
  // Suppress all logging when writing to stdout
  const originalLevel = consola.level;
  if (writeToStdout) {
    consola.level = LogLevels.silent;
  }

  try {
    const extraVariables = createExtraVariables(project.sources ?? [], writeToStdout);

    const files = [] as string[];

    for (const sql of project.sql) {
      // Group generators by engine for efficient database reuse
      const gensByEngine = new Map<DbEngine, typeof sql.gen>();

      for (const gen of sql.gen) {
        const engine = getGeneratorEngine(gen.generator);
        if (!gensByEngine.has(engine)) {
          gensByEngine.set(engine, []);
        }
        gensByEngine.get(engine)!.push(gen);
      }

      for (const sqlFile of sql.files) {
        const fullPath = join(projectDir, sqlFile);

        // Check SQL file exists
        if (!existsSync(fullPath)) {
          throw new FileNotFoundError(fullPath, projectDir);
        }

        let queries: SQLQuery[];
        let tables: TableInfo[];
        try {
          const parseResult = parseSQLQueries(fullPath, extraVariables);
          queries = parseResult.queries;
          tables = parseResult.tables;
        } catch (e) {
          if (e instanceof SqgError) {
            throw e;
          }
          throw SqgError.inFile(
            `Failed to parse SQL file: ${(e as Error).message}`,
            "SQL_PARSE_ERROR",
            sqlFile,
            { suggestion: "Check SQL syntax and annotation format" },
          );
        }

        // Process each engine group
        for (const [engine, gens] of gensByEngine) {
          try {
            const dbEngine = getDatabaseEngine(engine);
            await dbEngine.initializeDatabase(queries);
            await dbEngine.executeQueries(queries);
            // Introspect table schemas for appenders
            if (tables.length > 0) {
              await dbEngine.introspectTables(tables);
            }
            validateQueries(queries);
            await dbEngine.close();
          } catch (e) {
            if (e instanceof SqgError) {
              throw e;
            }
            throw new SqgError(
              `Database error processing ${sqlFile}: ${(e as Error).message}`,
              "DATABASE_ERROR",
              `Check that the SQL is valid for engine '${engine}'`,
              { file: sqlFile, engine },
            );
          }

          for (const gen of gens) {
            const generator = getGenerator(gen.generator);
            const genWithProject: GeneratorConfig = { ...gen, projectName: project.name };
            const outputPath = await writeGeneratedFile(
              projectDir,
              genWithProject,
              generator,
              sqlFile,
              queries,
              tables,
              engine,
              writeToStdout,
            );
            if (outputPath !== null) {
              files.push(outputPath);
            }
          }
        }
      }
    }
    return files;
  } finally {
    // Restore original logging level
    if (writeToStdout) {
      consola.level = originalLevel;
    }
  }
}

/**
 * Process a project configuration and generate code from a YAML file
 */
export async function processProject(projectPath: string) {
  const projectDir = resolve(dirname(projectPath));
  const project = parseProjectConfig(projectPath);
  return await processProjectFromConfig(project, projectDir, false);
}
