import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { homedir } from "node:os";
import { basename, dirname, extname, join, resolve } from "node:path";
import consola from "consola";
import Handlebars from "handlebars";
import YAML from "yaml";
import { z } from "zod";
import {
  SUPPORTED_ENGINES,
  SUPPORTED_GENERATORS,
  GENERATOR_NAMES,
  findSimilarGenerators,
  type SupportedEngine,
  type SupportedGenerator,
} from "./constants.js";
import { getDatabaseEngine } from "./db/index.js";
import {
  ConfigError,
  FileNotFoundError,
  GeneratorEngineMismatchError,
  InvalidEngineError,
  InvalidGeneratorError,
  SqgError,
  type ErrorContext,
} from "./errors.js";
import { type Generator, getGenerator } from "./generators/index.js";
import type { ColumnInfo, SQLQuery } from "./sql-query.js";
import { parseSQLQueries, StructType } from "./sql-query.js";
import type { TypeMapper } from "./type-mapping.js";

export const GENERATED_FILE_COMMENT = "This file is generated by SQG. Do not edit manually.";

const configSchema = z.object({
  result: z.record(z.string(), z.string()).optional(),
});

export class Config {
  constructor(public result: Map<string, ColumnInfo>) {}

  getColumnInfo(name: string): ColumnInfo | undefined {
    return this.result.get(name);
  }

  static fromYaml(name: string, filePath: string, configStr: string): Config {
    //consola.info("Config:", config);
    let configObj: unknown;
    try {
      configObj = YAML.parse(configStr);
      //consola.info("Config object:", configObj);
    } catch (e) {
      throw new Error(
        `Error parsing YAML config for query ${name} in ${filePath}: \n${configStr}\n ${e}`,
      );
    }
    const result = configSchema.safeParse(configObj);
    if (!result.success) {
      throw new Error(
        `Error parsing config for query ${name} in ${filePath}: \n${configStr}\n ${result.error}`,
      );
    }

    const columnMap = new Map<string, ColumnInfo>();
    for (const [name, info] of Object.entries(result.data.result ?? {})) {
      const parts = info
        .trim()
        .split(" ")
        .map((part) => part.trim());
      let type: string;
      let nullable = true;
      if (parts.length === 1) {
        type = parts[0];
      } else if (parts.length === 2) {
        type = parts[0];
        if (parts[1].toLocaleLowerCase() !== "null") {
          throw new Error(
            `Invalid config for column ${name} in ${filePath}: \n${configStr}\n ${info}`,
          );
        }
        nullable = true;
      } else if (parts.length === 3) {
        type = parts[0];
        if (parts[1].toLocaleLowerCase() !== "not" || parts[2].toLocaleLowerCase() !== "null") {
          throw new Error(
            `Invalid config for column ${name} in ${filePath}: \n${configStr}\n ${info}`,
          );
        }
        nullable = false;
      } else {
        throw new Error(
          `Invalid config for column ${name} in ${filePath}: \n${configStr}\n ${info}`,
        );
      }
      columnMap.set(name, {
        name,
        type,
        nullable,
      });
    }
    return new Config(columnMap);
  }
}

export type ParameterEntry = {
  name: string;
  value: string;
};

export type SqlQueryPart = string | ParameterEntry;

export type SqlQueryStatement = {
  sql: string; // for backwards compatibility, use sqlParts instead

  sqlParts: SqlQueryPart[];

  parameters: ParameterEntry[];
};

/** Util class to help generating a query with a given generator */
export class SqlQueryHelper {
  constructor(
    public query: SQLQuery,
    public generator: Generator,
    public statement: SqlQueryStatement,
  ) {}

  get id(): string {
    return this.query.id;
  }

  get isQuery(): boolean {
    return this.query.isQuery;
  }

  get isExec(): boolean {
    return this.query.isExec;
  }

  get isMigrate(): boolean {
    return this.query.isMigrate;
  }

  get isPluck(): boolean {
    return this.query.isPluck;
  }

  get isOne(): boolean {
    return this.query.isOne;
  }

  get parameterNames(): string[] {
    return this.statement.parameters.map((param) => param.name);
  }

  get skipGenerateFunction(): boolean {
    return this.query.skipGenerateFunction;
  }

  get parameters(): { name: string; type: string }[] {
    const vars = new Map(this.variables.map((param) => [param.name, param.type]));
    return this.statement.parameters.map((param) => ({
      name: param.name,
      type: vars.get(param.name)!,
    }));
  }

  get columns(): ColumnInfo[] {
    if (!(this.query.allColumns.type instanceof StructType)) {
      throw new Error(`Expected StructType ${this.query.allColumns.type}`);
    }
    return (this.query.allColumns.type as StructType).fields;
  }

  get variables(): { name: string; type: string }[] {
    return Array.from(this.query.variables.entries()).map(([name, value]) => ({
      name,
      type: this.generator.mapParameterType(detectParameterType(value), false),
    }));
  }

  get sqlQuery(): string {
    return this.statement.sql;
  }

  get sqlQueryParts(): SqlQueryPart[] {
    return this.statement.sqlParts;
  }

  private get rowTypeStr(): string {
    return this.generator.rowType(this.query);
  }

  get functionReturnType(): string | Handlebars.SafeString {
    return new Handlebars.SafeString(this.generator.functionReturnType(this.query));
  }

  get rowType(): Handlebars.SafeString {
    return new Handlebars.SafeString(this.rowTypeStr);
  }

  get functionName(): string {
    return this.generator.getFunctionName(this.query.id);
  }

  get typeMapper(): TypeMapper {
    return this.generator.typeMapper;
  }
}

function generateSourceFile(
  name: string,
  queries: SQLQuery[],
  templatePath: string,
  generator: Generator,
  config?: any,
): string {
  const templateSrc = readFileSync(templatePath, "utf-8");

  const template = Handlebars.compile(templateSrc);
  Handlebars.registerHelper("mapType", (column: ColumnInfo) => generator.mapType(column));
  Handlebars.registerHelper("plusOne", (value: number) => value + 1);

  const migrations = queries
    .filter((q) => q.isMigrate)
    .map((q) => new SqlQueryHelper(q, generator, generator.getStatement(q)));
  const result = template(
    {
      generatedComment: GENERATED_FILE_COMMENT,
      migrations,
      queries: queries.map((q) => new SqlQueryHelper(q, generator, generator.getStatement(q))),
      className: generator.getClassName(name),
      config,
    },
    {
      allowProtoPropertiesByDefault: true,
      allowProtoMethodsByDefault: true,
    },
  );

  return result;
}

/**
 * Project configuration schema with descriptions for validation messages
 */
const ProjectSchema = z.object({
  version: z
    .number()
    .describe("Configuration version (currently 1)"),
  name: z
    .string()
    .min(1, "Project name is required")
    .describe("Project name used for generated class names"),
  sql: z
    .array(
      z.object({
        engine: z
          .enum(SUPPORTED_ENGINES)
          .describe(`Database engine: ${SUPPORTED_ENGINES.join(", ")}`),
        files: z
          .array(z.string().min(1))
          .min(1, "At least one SQL file is required")
          .describe("SQL files to process"),
        gen: z
          .array(
            z.object({
              generator: z
                .enum(GENERATOR_NAMES as unknown as readonly [string, ...string[]])
                .describe(`Code generator: ${GENERATOR_NAMES.join(", ")}`),
              name: z
                .string()
                .optional()
                .describe("Override the generated class/module name"),
              template: z
                .string()
                .optional()
                .describe("Custom Handlebars template path"),
              output: z
                .string()
                .min(1, "Output path is required")
                .describe("Output file or directory path"),
              config: z
                .any()
                .optional()
                .describe("Generator-specific configuration"),
            }),
          )
          .min(1, "At least one generator is required")
          .describe("Code generators to run"),
      }),
    )
    .min(1, "At least one SQL configuration is required")
    .describe("SQL file configurations"),
  sources: z
    .array(
      z.object({
        path: z.string().describe("Path to source file (supports $HOME)"),
        name: z.string().optional().describe("Variable name override"),
      }),
    )
    .optional()
    .describe("External source files to include as variables"),
});

type Project = z.infer<typeof ProjectSchema>;
type Source = NonNullable<z.infer<typeof ProjectSchema.shape.sources>>[number];

export class ExtraVariable {
  constructor(
    public name: string,
    public value: string,
  ) {}
}

export function createExtraVariables(sources: Source[]): ExtraVariable[] {
  return sources.map((source) => {
    const path = source.path;
    const resolvedPath = path.replace("$HOME", homedir());
    const name = source.name ?? basename(path, extname(resolvedPath));
    const varName = `sources_${name.replace(/\s+/g, "_")}`;
    consola.info("Extra variable:", varName, resolvedPath);
    return new ExtraVariable(varName, `'${resolvedPath}'`);
  });
}

/**
 * Parse and validate project configuration with helpful error messages
 */
export function parseProjectConfig(filePath: string): Project {
  if (!existsSync(filePath)) {
    throw new FileNotFoundError(filePath, process.cwd());
  }

  let content: string;
  try {
    content = readFileSync(filePath, "utf-8");
  } catch (e) {
    throw new SqgError(
      `Cannot read config file: ${filePath}`,
      "CONFIG_PARSE_ERROR",
      "Check file permissions and that the path is correct",
    );
  }

  let parsed: unknown;
  try {
    parsed = YAML.parse(content);
  } catch (e) {
    const yamlError = e as Error;
    throw new SqgError(
      `Invalid YAML syntax in ${filePath}: ${yamlError.message}`,
      "CONFIG_PARSE_ERROR",
      "Check YAML syntax - common issues: incorrect indentation, missing colons, unquoted special characters",
    );
  }

  // Pre-validate to give better error messages for common mistakes
  if (parsed && typeof parsed === "object") {
    const obj = parsed as Record<string, unknown>;

    // Check for invalid engine before Zod validation
    if (obj.sql && Array.isArray(obj.sql)) {
      for (let i = 0; i < obj.sql.length; i++) {
        const sqlConfig = obj.sql[i] as Record<string, unknown>;
        if (sqlConfig.engine && !SUPPORTED_ENGINES.includes(sqlConfig.engine as SupportedEngine)) {
          throw new InvalidEngineError(String(sqlConfig.engine), [...SUPPORTED_ENGINES]);
        }

        // Check for invalid generators
        if (sqlConfig.gen && Array.isArray(sqlConfig.gen)) {
          for (let j = 0; j < sqlConfig.gen.length; j++) {
            const genConfig = sqlConfig.gen[j] as Record<string, unknown>;
            if (genConfig.generator && !GENERATOR_NAMES.includes(genConfig.generator as SupportedGenerator)) {
              const similar = findSimilarGenerators(String(genConfig.generator));
              throw new InvalidGeneratorError(
                String(genConfig.generator),
                [...GENERATOR_NAMES],
                similar.length > 0 ? similar[0] : undefined,
              );
            }
          }
        }
      }
    }
  }

  const result = ProjectSchema.safeParse(parsed);
  if (!result.success) {
    const prettyError = z.prettifyError(result.error);
    throw new ConfigError(
      `Configuration error in ${filePath}:\n${prettyError}`,
      "Check the configuration format against the documentation at https://sqg.dev",
      { file: filePath },
    );
  }

  return result.data;
}

function detectParameterType(value: string): string {
  const num = Number(value);
  if (!Number.isNaN(num)) {
    if (Number.isInteger(num)) {
      return "INTEGER";
    }
    return "REAL";
  }
  if (value.toLowerCase() === "true" || value.toLowerCase() === "false") {
    return "BOOLEAN";
  }
  return "TEXT";
}

export interface GeneratorConfig {
  generator: string;
  output: string;
  template?: string;
  config?: any;
  name?: string;
}

export function getOutputPath(
  projectDir: string,
  sqlFileName: string,
  gen: { generator: string; output: string },
  generator: Generator,
) {
  const pathParts: string[] = [];
  if (!gen.output.startsWith("/")) {
    pathParts.push(projectDir);
  }
  if (gen.output.endsWith("/")) {
    const name = generator.getFilename(sqlFileName);
    pathParts.push(gen.output, name);
  } else {
    pathParts.push(gen.output);
  }
  const outputPath = join(...pathParts);
  mkdirSync(dirname(outputPath), { recursive: true });
  return outputPath;
}

export function validateQueries(queries: SQLQuery[]) {
  for (const query of queries) {
    if (query.isQuery && query.isPluck && query.columns.length !== 1) {
      throw SqgError.inQuery(
        `':pluck' modifier requires exactly 1 column, but query has ${query.columns.length} columns`,
        "VALIDATION_ERROR",
        query.id,
        query.filename,
        {
          suggestion: query.columns.length === 0
            ? "Ensure the query returns at least one column"
            : `Remove ':pluck' or select only one column. Current columns: ${query.columns.map((c) => c.name).join(", ")}`,
        },
      );
    }
    const columns = query.columns.map((col) => {
      const configColumn = query.config?.getColumnInfo(col.name);
      if (configColumn) {
        return configColumn;
      }
      return col;
    });
    query.allColumns = {
      name: query.id,
      nullable: false,
      type: new StructType(columns),
    };
  }
}

export async function writeGeneratedFile(
  projectDir: string,
  gen: GeneratorConfig,
  generator: Generator,
  file: string,
  queries: SQLQuery[],
) {
  await generator.beforeGenerate(projectDir, gen, queries);
  const templateDir = dirname(new URL(import.meta.url).pathname);
  const templatePath = join(templateDir, gen.template ?? generator.template);
  const name = gen.name ?? basename(file, extname(file));
  const sourceFile = generateSourceFile(name, queries, templatePath, generator, gen.config);
  const outputPath = getOutputPath(projectDir, name, gen, generator);
  writeFileSync(outputPath, sourceFile);
  consola.success(`Generated ${outputPath}`);
  await generator.afterGenerate(outputPath);
  return outputPath;
}

/**
 * Validation result for pre-flight checks
 */
export interface ValidationResult {
  valid: boolean;
  project?: {
    name: string;
    version: number;
  };
  sqlFiles?: string[];
  generators?: string[];
  errors?: Array<{
    code: string;
    message: string;
    suggestion?: string;
    context?: ErrorContext;
  }>;
}

/**
 * Validate project configuration without executing queries
 * Use this for pre-flight checks before generation
 */
export async function validateProject(projectPath: string): Promise<ValidationResult> {
  const errors: ValidationResult["errors"] = [];
  const projectDir = resolve(dirname(projectPath));

  // Parse and validate config
  let project: Project;
  try {
    project = parseProjectConfig(projectPath);
  } catch (e) {
    if (e instanceof SqgError) {
      return {
        valid: false,
        errors: [
          {
            code: e.code,
            message: e.message,
            suggestion: e.suggestion,
            context: e.context,
          },
        ],
      };
    }
    return {
      valid: false,
      errors: [{ code: "UNKNOWN_ERROR", message: String(e) }],
    };
  }

  const sqlFiles: string[] = [];
  const generators: string[] = [];

  // Validate each SQL configuration
  for (const sql of project.sql) {
    for (const sqlFile of sql.files) {
      const fullPath = join(projectDir, sqlFile);
      sqlFiles.push(sqlFile);

      // Check SQL file exists
      if (!existsSync(fullPath)) {
        errors.push({
          code: "FILE_NOT_FOUND",
          message: `SQL file not found: ${sqlFile}`,
          suggestion: `Check that ${sqlFile} exists relative to ${projectDir}`,
          context: { file: fullPath },
        });
      }

      // Validate generator compatibility
      for (const gen of sql.gen) {
        generators.push(gen.generator);

        const generatorInfo = SUPPORTED_GENERATORS[gen.generator as SupportedGenerator];
        if (!(generatorInfo.compatibleEngines as readonly string[]).includes(sql.engine)) {
          errors.push({
            code: "GENERATOR_ENGINE_MISMATCH",
            message: `Generator '${gen.generator}' is not compatible with engine '${sql.engine}'`,
            suggestion: `For '${sql.engine}', use one of: ${Object.entries(SUPPORTED_GENERATORS)
              .filter(([_, info]) => (info.compatibleEngines as readonly string[]).includes(sql.engine))
              .map(([name]) => name)
              .join(", ")}`,
            context: { generator: gen.generator, engine: sql.engine },
          });
        }
      }
    }
  }

  return {
    valid: errors.length === 0,
    project: {
      name: project.name,
      version: project.version,
    },
    sqlFiles: [...new Set(sqlFiles)],
    generators: [...new Set(generators)],
    errors: errors.length > 0 ? errors : undefined,
  };
}

/**
 * Process a project configuration and generate code
 */
export async function processProject(projectPath: string) {
  const projectDir = resolve(dirname(projectPath));
  const project = parseProjectConfig(projectPath);

  const extraVariables = createExtraVariables(project.sources ?? []);
  if (extraVariables.length > 0) {
    consola.info("Extra variables:", extraVariables);
  }

  const files = [] as string[];

  for (const sql of project.sql) {
    // Pre-validate generator compatibility before any work
    for (const gen of sql.gen) {
      const generatorInfo = SUPPORTED_GENERATORS[gen.generator as SupportedGenerator];
      if (!(generatorInfo.compatibleEngines as readonly string[]).includes(sql.engine)) {
        throw new GeneratorEngineMismatchError(
          gen.generator,
          sql.engine,
          generatorInfo.compatibleEngines,
        );
      }
    }

    for (const sqlFile of sql.files) {
      const fullPath = join(projectDir, sqlFile);

      // Check SQL file exists
      if (!existsSync(fullPath)) {
        throw new FileNotFoundError(fullPath, projectDir);
      }

      let queries: SQLQuery[];
      try {
        queries = parseSQLQueries(fullPath, extraVariables);
      } catch (e) {
        if (e instanceof SqgError) {
          throw e;
        }
        throw SqgError.inFile(
          `Failed to parse SQL file: ${(e as Error).message}`,
          "SQL_PARSE_ERROR",
          sqlFile,
          { suggestion: "Check SQL syntax and annotation format" },
        );
      }

      try {
        const dbEngine = getDatabaseEngine(sql.engine);
        await dbEngine.initializeDatabase(queries);
        await dbEngine.executeQueries(queries);
        validateQueries(queries);
        await dbEngine.close();
      } catch (e) {
        if (e instanceof SqgError) {
          throw e;
        }
        throw new SqgError(
          `Database error processing ${sqlFile}: ${(e as Error).message}`,
          "DATABASE_ERROR",
          `Check that the SQL is valid for engine '${sql.engine}'`,
          { file: sqlFile, engine: sql.engine },
        );
      }

      for (const gen of sql.gen) {
        const generator = getGenerator(gen.generator);
        const outputPath = await writeGeneratedFile(projectDir, gen, generator, sqlFile, queries);
        files.push(outputPath);
      }
    }
  }
  return files;
}
