// {{generatedComment}}
package {{config.package}};

import java.sql.Array;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Struct;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.HashMap;
import java.util.Collections;
import java.util.UUID;
import java.util.function.Function;
{{#if tables.length}}
import org.duckdb.DuckDBAppender;
import org.duckdb.DuckDBConnection;
{{/if}}

public class {{className}} {
    private final Connection connection;

    public {{className}}(Connection connection) {
        this.connection = connection;
    }

    private static Object[] getObjectArray(Array array) {
        if (array == null) {
            return null;
        }
        try {
            return (Object[]) array.getArray();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
    private static Object[] getAttr(Struct struct) {
        if (struct == null) {
            return null;
        }
        try {
            return struct.getAttributes();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    private static LocalDateTime toLocalDateTime(java.sql.Timestamp ts) {
        return ts != null ? ts.toLocalDateTime() : null;
    }

    private static LocalDate toLocalDate(java.sql.Date d) {
        return d != null ? d.toLocalDate() : null;
    }

    private static LocalTime toLocalTime(java.sql.Time t) {
        return t != null ? t.toLocalTime() : null;
    }
    
    private static <K> List<K> arrayToList(
        Array array,
        Class<? extends K[]> baseType
    )  {
        var objectArray = getObjectArray(array);
        if (objectArray == null) {
            return null;
        }
        return Collections.unmodifiableList(
            Arrays.asList(
                Arrays.copyOf(objectArray, objectArray.length, baseType)
            )
        );
    }

    private static <K> List<K> arrayOfStructToList(
        Array array,
        Function<Object[], K> convert
    )  {
        var objectArray = getObjectArray(array);
        if (objectArray == null) {
            return null;
        }
        var list = new ArrayList<K>(objectArray.length);
        for (Object obj : objectArray) {
            list.add(obj != null ? convert.apply(getAttr((Struct)obj)) : null);
        }
        return Collections.unmodifiableList(list);
    }

    @SuppressWarnings("unchecked")
    private static <K> List<List<K>> multiDimArrayToList(
        Array array,
        Class<? extends K[]> baseType
    )  {
        var objectArray = getObjectArray(array);
        if (objectArray == null) {
            return null;
        }
        var list = new ArrayList<List<K>>(objectArray.length);
        for (Object obj : objectArray) {
            if (obj == null) {
                list.add(null);
            } else if (obj instanceof Array) {
                list.add(arrayToList((Array)obj, baseType));
            } else if (obj instanceof Object[]) {
                var inner = (Object[]) obj;
                list.add(Collections.unmodifiableList(
                    Arrays.asList(Arrays.copyOf(inner, inner.length, baseType))
                ));
            } else {
                throw new RuntimeException("Unexpected type in multi-dimensional array: " + obj.getClass());
            }
        }
        return Collections.unmodifiableList(list);
    }

    private static final List<String> migrations = List.of(
        {{#each migrations}}"""
{{{sqlQuery}}}"""{{#unless @last}},{{/unless}}
        {{/each}}
    );

    public static List<String> getMigrations() {   
        return migrations;
    }

    {{#each queries}}
    {{#unless skipGenerateFunction}}
    {{>columnTypesRecord}}
    public {{> returnType}} {{functionName}}({{#each variables}}{{{type}}} {{name}}{{#unless @last}}, {{/unless}}{{/each}}) throws SQLException {
        try (var stmt = connection.prepareStatement({{{partsToString sqlQueryParts}}})) {
            {{> execute}}
        }
    }
    {{/unless}}
    {{/each}}

    {{#if tables.length}}
    // ==================== Appenders ====================
    {{#each tables}}

    /** Create an appender for bulk inserts into {{tableName}} */
    public {{className}} {{functionName}}() throws SQLException {
        return new {{className}}(((DuckDBConnection) connection).createAppender(DuckDBConnection.DEFAULT_SCHEMA, "{{tableName}}"));
    }
    {{/each}}
    {{/if}}


{{#each tables}}
/** Row type for {{tableName}} appender */
public record {{rowTypeName}}({{#each columns}}{{mapType this}} {{name}}{{#unless @last}}, {{/unless}}{{/each}}) {}

/** Appender for bulk inserts into {{tableName}} */
public static class {{className}} implements AutoCloseable {
    private final DuckDBAppender appender;

    {{className}}(DuckDBAppender appender) {
        this.appender = appender;
    }

    /** Get the underlying DuckDB appender for advanced operations */
    public DuckDBAppender getAppender() {
        return appender;
    }

    /** Append a single row */
    public {{className}} append({{rowTypeName}} row) throws SQLException {
        appender.beginRow();
        {{#each columns}}
        appender.append(row.{{name}}());
        {{/each}}
        appender.endRow();
        return this;
    }

    /** Append a single row with individual values */
    public {{className}} append({{#each columns}}{{mapType this}} {{name}}{{#unless @last}}, {{/unless}}{{/each}}) throws SQLException {
        appender.beginRow();
        {{#each columns}}
        appender.append({{name}});
        {{/each}}
        appender.endRow();
        return this;
    }

    /** Append multiple rows */
    public {{className}} appendMany(Iterable<{{rowTypeName}}> rows) throws SQLException {
        for (var row : rows) {
            append(row);
        }
        return this;
    }

    /** Flush and close the appender */
    @Override
    public void close() throws SQLException {
        appender.close();
    }
}
{{/each}}
}

{{#*inline "columnTypesRecord"}}
{{#if isQuery}}
{{{declareTypes this}}}
{{/if}}
{{/inline}}

{{#*inline "returnType"}}
{{#if isQuery~}}
{{functionReturnType}}
{{~else~}}
int
{{~/if~}}
{{/inline~}}

{{#*inline "readRow"}}
{{{readColumns this}}}
{{/inline~}}

{{#*inline "execute"}}
{{#each parameterNames}}stmt.setObject({{plusOne @index}}, {{this}});
{{/each}}
{{#if isQuery}}
try(var rs = stmt.executeQuery()) {
{{#if isOne}}
        return rs.next() ? {{> readRow}} : null;    
{{else}}
var results = new ArrayList<{{rowType}}>();
while (rs.next()) {
    results.add({{> readRow}});
}
return results;
{{/if}}
}
{{else}}
return stmt.executeUpdate();
{{/if}}
{{/inline}}
