// This file is generated by SQG (https://sqg.dev). Do not edit manually.
import type {
  DuckDBConnection,
  DuckDBMaterializedResult,
  DuckDBAppender,
  DuckDBDateValue,
  DuckDBTimeValue,
  DuckDBTimestampValue,
  DuckDBBlobValue,
} from "@duckdb/node-api";

export class Queries {
  constructor(private conn: DuckDBConnection) {}

  static getMigrations(): string[] {
    return [
      `CREATE SEQUENCE IF NOT EXISTS seq_users_id START 1;
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY DEFAULT nextval('seq_users_id'),
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT current_timestamp
);`,
      `CREATE SEQUENCE IF NOT EXISTS seq_posts_id START 1;
CREATE TABLE IF NOT EXISTS posts (
    id INTEGER PRIMARY KEY DEFAULT nextval('seq_posts_id'),
    user_id INTEGER NOT NULL REFERENCES users(id),
    title TEXT NOT NULL,
    content TEXT,
    published BOOLEAN DEFAULT false,
    tags TEXT[],
    metadata STRUCT(views INTEGER, likes INTEGER, featured BOOLEAN),
    created_at TIMESTAMP DEFAULT current_timestamp
);`,
      `CREATE TABLE IF NOT EXISTS topics (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMP
);`,
    ];
  }

  static getQueryNames(): Map<string, keyof Queries> {
    return new Map([
      ["getTopics", "getTopics"],
      ["insertUser", "insertUser"],
      ["getUsers", "getUsers"],
      ["getUserById", "getUserById"],
      ["getUserByEmail", "getUserByEmail"],
      ["insertPost", "insertPost"],
      ["getPostsByUser", "getPostsByUser"],
      ["getPublishedPosts", "getPublishedPosts"],
      ["countUserPosts", "countUserPosts"],
    ]);
  }

  async getTopics(): Promise<
    {
      id: number | null;
      name: string | null;
      description: string | null;
      created_at: { micros: bigint } | null;
    }[]
  > {
    const sql = "SELECT * from topics;";
    const reader = await this.conn.runAndReadAll(sql, []);
    return reader.getRowObjects() as {
      id: number | null;
      name: string | null;
      description: string | null;
      created_at: { micros: bigint } | null;
    }[];
  }

  async insertUser(
    name: string,
    email: string,
  ): Promise<DuckDBMaterializedResult> {
    const sql = "INSERT INTO users (name, email) VALUES ( ?, ?);";
    return await this.conn.run(sql, [name, email]);
  }

  async getUsers(): Promise<
    {
      id: number | null;
      name: string | null;
      email: string | null;
      created_at: { micros: bigint } | null;
    }[]
  > {
    const sql = "SELECT id, name, email, created_at FROM users;";
    const reader = await this.conn.runAndReadAll(sql, []);
    return reader.getRowObjects() as {
      id: number | null;
      name: string | null;
      email: string | null;
      created_at: { micros: bigint } | null;
    }[];
  }

  async getUserById(
    id: number,
  ): Promise<
    | {
        id: number | null;
        name: string | null;
        email: string | null;
        created_at: { micros: bigint } | null;
      }
    | undefined
  > {
    const sql = "SELECT id, name, email, created_at FROM users WHERE id =?;";
    const reader = await this.conn.runAndReadAll(sql, [id]);
    return reader.getRowObjects()[0] as
      | {
          id: number | null;
          name: string | null;
          email: string | null;
          created_at: { micros: bigint } | null;
        }
      | undefined;
  }

  async getUserByEmail(
    email: string,
  ): Promise<
    | {
        id: number | null;
        name: string | null;
        email: string | null;
        created_at: { micros: bigint } | null;
      }
    | undefined
  > {
    const sql = "SELECT id, name, email, created_at FROM users WHERE email =?;";
    const reader = await this.conn.runAndReadAll(sql, [email]);
    return reader.getRowObjects()[0] as
      | {
          id: number | null;
          name: string | null;
          email: string | null;
          created_at: { micros: bigint } | null;
        }
      | undefined;
  }

  async insertPost(
    userId: number,
    title: string,
    content: string,
    published: boolean,
  ): Promise<DuckDBMaterializedResult> {
    const sql = `INSERT INTO posts (user_id, title, content, published, tags, metadata)
VALUES ( ?, ?, ?, ?, ['general'], {'views': 0, 'likes': 0, 'featured': false});`;
    return await this.conn.run(sql, [userId, title, content, published]);
  }

  async getPostsByUser(
    userId: number,
  ): Promise<
    {
      id: number | null;
      user_id: number | null;
      title: string | null;
      content: string | null;
      published: boolean | null;
      tags: { items: (string | null)[] };
      metadata: {
        entries: {
          views: number | null;
          likes: number | null;
          featured: boolean | null;
        };
      };
      created_at: { micros: bigint } | null;
    }[]
  > {
    const sql = `SELECT id, user_id, title, content, published, tags, metadata, created_at
FROM posts WHERE user_id =?;`;
    const reader = await this.conn.runAndReadAll(sql, [userId]);
    return reader.getRowObjects() as {
      id: number | null;
      user_id: number | null;
      title: string | null;
      content: string | null;
      published: boolean | null;
      tags: { items: (string | null)[] };
      metadata: {
        entries: {
          views: number | null;
          likes: number | null;
          featured: boolean | null;
        };
      };
      created_at: { micros: bigint } | null;
    }[];
  }

  async getPublishedPosts(): Promise<
    {
      id: number | null;
      title: string | null;
      content: string | null;
      created_at: { micros: bigint } | null;
      author_name: string | null;
    }[]
  > {
    const sql = `SELECT p.id, p.title, p.content, p.created_at, u.name as author_name
FROM posts p
JOIN users u ON p.user_id = u.id
WHERE p.published = true;`;
    const reader = await this.conn.runAndReadAll(sql, []);
    return reader.getRowObjects() as {
      id: number | null;
      title: string | null;
      content: string | null;
      created_at: { micros: bigint } | null;
      author_name: string | null;
    }[];
  }

  async countUserPosts(userId: number): Promise<bigint | null | undefined> {
    const sql = "SELECT COUNT(*) FROM posts WHERE user_id =?;";
    const reader = await this.conn.runAndReadAll(sql, [userId]);
    return reader.getRows()[0]?.[0] as bigint | null | undefined;
  }

  // ==================== Appenders ====================

  async createTopicsAppender(): Promise<TopicsAppender> {
    return new TopicsAppender(await this.conn.createAppender("topics"));
  }
}

/** Row type for topics appender */
export interface TopicsRow {
  id: number;
  name: string;
  description: string | null;
  created_at: DuckDBTimestampValue | null;
}

/** Appender for bulk inserts into topics */
export class TopicsAppender {
  constructor(public readonly appender: DuckDBAppender) {}

  /** Append a single row */
  append(row: TopicsRow): this {
    this.appender.appendInteger(row.id);
    this.appender.appendVarchar(row.name);
    if (row.description === null || row.description === undefined) {
      this.appender.appendNull();
    } else {
      this.appender.appendVarchar(row.description);
    }
    if (row.created_at === null || row.created_at === undefined) {
      this.appender.appendNull();
    } else {
      this.appender.appendTimestamp(row.created_at);
    }
    this.appender.endRow();
    return this;
  }

  /** Append multiple rows */
  appendMany(rows: TopicsRow[]): this {
    for (const row of rows) {
      this.append(row);
    }
    return this;
  }

  /** Flush buffered data to the table */
  flush(): this {
    this.appender.flushSync();
    return this;
  }

  /** Flush and close the appender */
  close(): void {
    this.appender.closeSync();
  }
}
