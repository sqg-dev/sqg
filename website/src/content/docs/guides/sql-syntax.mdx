---
title: SQL Syntax Reference
description: Complete reference for SQG query annotations and modifiers
---

import CodeExample from '@components/CodeExample.astro';

This page documents all SQL annotations and modifiers supported by SQG.

## DBeaver Compatibility

SQG's syntax is designed to be **fully compatible with [DBeaver](https://dbeaver.io)**, the popular open-source database IDE. The `@set` variable syntax and `${variable}` references are native DBeaver features, which means you can:

- **Develop queries interactively** with full autocomplete for tables and columns
- **Execute and test queries** directly in DBeaver before generating code
- **Modify `@set` values** and re-run to test different parameter scenarios
- **Debug with query plans** to optimize performance

This compatibility lets you use DBeaver as your primary SQL development environmentâ€”write and test queries there, then run `sqg` to generate type-safe code.

## File Structure

An SQG SQL file contains multiple blocks, each starting with a comment annotation:

<CodeExample id="file-structure" />

## Block Types

### MIGRATE

Schema migrations are executed in order to set up the database structure.

```sql
-- MIGRATE 1
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- MIGRATE 2
CREATE INDEX idx_users_name ON users(name);

-- MIGRATE 3
ALTER TABLE users ADD COLUMN email TEXT UNIQUE;
```

**Rules:**
- Migrations must be numbered sequentially starting from 1
- Each migration is executed once during type introspection
- Generated code includes a `getMigrations()` static method returning migration SQL strings
- Use the built-in `applyMigrations()` function (see below) or manage migration tracking yourself

### Built-in Migration Runner

SQG can generate an `applyMigrations()` function that automatically tracks and applies migrations. Enable it with `config.migrations: true`:

```yaml
# sqg.yaml
gen:
  - generator: typescript/sqlite
    output: ./src/generated/
    config:
      migrations: true
```

This generates a static `applyMigrations()` method that:
- Creates a `_sqg_migrations` tracking table (if it doesn't exist)
- Checks which migrations have already been applied for this project
- Applies unapplied migrations in order
- Records each applied migration with a timestamp
- Runs everything inside a transaction for safety

The tracking table uses the project `name` from your `sqg.yaml` to scope migrations, so **multiple sqg projects can share the same database** without conflicts.

**TypeScript (SQLite):**
```typescript
// Apply migrations with default project name (from sqg.yaml)
MyApp.applyMigrations(db);

// Override project name (for multi-tenant scenarios)
MyApp.applyMigrations(db, 'custom-project-name');
```

**TypeScript (DuckDB):**
```typescript
await MyApp.applyMigrations(connection);
```

**Java (JDBC):**
```java
MyApp.applyMigrations(connection);

// Or with a custom project name
MyApp.applyMigrations(connection, "custom-project-name");
```

The `_sqg_migrations` table schema:

| Column | Type | Description |
|--------|------|-------------|
| `project` | TEXT | Project name (from `sqg.yaml`) |
| `migration_id` | TEXT | Migration identifier (e.g., `"1"`, `"2"`) |
| `applied_at` | TIMESTAMP | When the migration was applied |

Primary key: `(project, migration_id)`

### TESTDATA

Populate sample data used during type introspection. This data helps SQG understand nullable columns and complex return types.

```sql
-- TESTDATA
INSERT INTO users (id, name, email) VALUES
  (1, 'Alice', 'alice@example.com'),
  (2, 'Bob', 'bob@example.com');

INSERT INTO posts (id, user_id, title) VALUES
  (1, 1, 'Hello World');
```

**Rules:**
- TESTDATA blocks are executed after all migrations
- Use meaningful test data that exercises your queries
- Data is only used during generation, not included in output

### QUERY

Select queries that return data.

```sql
-- QUERY find_active_users
SELECT * FROM users WHERE active = true;
```

**Generated code returns:**
- Array of row objects (default)
- Single row with `:one` modifier
- Column values with `:pluck` modifier

### EXEC

Execute statements that don't return rows (INSERT, UPDATE, DELETE).

```sql
-- EXEC deactivate_user
@set id = 1
UPDATE users SET active = false WHERE id = ${id};
```

**Generated code returns:**
- Database-specific result type (e.g., `RunResult` for SQLite)
- Typically includes `changes` count and `lastInsertRowid`

### TABLE (DuckDB Only)

Generate high-performance bulk insert appenders for DuckDB tables. Appenders provide significantly faster inserts than individual INSERT statements.

```sql
-- TABLE users :appender
```

**Syntax:**
- `-- TABLE <table_name> :appender` - generates an appender for the specified table
- The `:appender` modifier is required
- SQG introspects the table schema to generate type-safe row interfaces

**Generated code includes:**
- A factory method to create the appender (e.g., `createUsersAppender()`)
- A typed row interface (e.g., `UsersRow`)
- An appender class with `append()`, `appendMany()`, `flush()`, and `close()` methods

**Example:**

```sql
-- MIGRATE 1
CREATE TABLE events (
    id INTEGER PRIMARY KEY,
    event_type VARCHAR NOT NULL,
    payload VARCHAR,
    created_at TIMESTAMP
);

-- TABLE events :appender
```

```typescript
// Generated interface
interface EventsRow {
  id: number;
  event_type: string;
  payload: string | null;
  created_at: DuckDBTimestampValue | null;
}

// Usage
const appender = await queries.createEventsAppender();

// Append rows (10-100x faster than INSERT)
appender.append({ id: 1, event_type: 'click', payload: null, created_at: null });
appender.appendMany([
  { id: 2, event_type: 'view', payload: '{"page": "home"}', created_at: null },
  { id: 3, event_type: 'click', payload: null, created_at: null },
]);

appender.flush();  // Flush buffered data to table
appender.close();  // Flush and release resources
```

**Notes:**
- Appenders are only supported with the `typescript/duckdb` generator
- Use appenders for batch inserts (ETL, data pipelines, bulk imports)
- Call `flush()` periodically for long-running imports
- Always call `close()` when done to release resources
- See [TypeScript + DuckDB](/generators/typescript-duckdb/#bulk-inserts-with-appenders) for detailed usage

## Modifiers

Modifiers change how query results are returned. Add them after the query name:

```sql
-- QUERY name :modifier1 :modifier2
```

### :all (default)

Returns all matching rows as an array.

```sql
-- QUERY get_users :all
SELECT * FROM users;
```

```typescript
// Generated: User[]
getUsers(): { id: number | null; name: string | null; }[]
```

### :one

Returns a single row or undefined. Use for queries expected to return 0 or 1 rows.

```sql
-- QUERY get_user :one
@set id = 1
SELECT * FROM users WHERE id = ${id};
```

```typescript
// Generated: User | undefined
getUser(id: number): { id: number | null; name: string | null; } | undefined
```

### :pluck

Extracts values from the first (or only) column. Useful for fetching lists of IDs or scalar values.

```sql
-- QUERY get_user_ids :pluck
SELECT id FROM users;
```

```typescript
// Generated: (number | null)[]
getUserIds(): (number | null)[]
```

### Combining Modifiers

Modifiers can be combined:

```sql
-- QUERY count_users :one :pluck
SELECT COUNT(*) FROM users;
```

```typescript
// Generated: number | null | undefined
countUsers(): number | null | undefined
```

```sql
-- QUERY get_first_email :one :pluck
SELECT email FROM users ORDER BY id LIMIT 1;
```

```typescript
// Generated: string | null | undefined
getFirstEmail(): string | null | undefined
```

## Parameters

### Defining Parameters

Use `@set` to define parameters with sample values:

```sql
-- QUERY find_users_by_name
@set name = 'John'
SELECT * FROM users WHERE name = ${name};
```

The sample value (`'John'`) is used during type introspection. At runtime, the parameter becomes a function argument.

### Multiple Parameters

```sql
-- QUERY find_users
@set name = 'John'
@set min_age = 18
@set max_age = 65
SELECT * FROM users
WHERE name LIKE ${name}
  AND age >= ${min_age}
  AND age <= ${max_age};
```

```typescript
findUsers(name: string, min_age: number, max_age: number): User[]
```

### Parameter Order

Parameters appear in the generated function in the order they're defined with `@set`:

```sql
-- QUERY example
@set first = 'a'
@set second = 1
@set third = true
SELECT * FROM t WHERE a = ${first} AND b = ${second} AND c = ${third};
```

```typescript
example(first: string, second: number, third: boolean): Result[]
```

### Parameter Types

Parameter types are inferred from the sample values:

| Sample Value | Inferred Type |
|--------------|---------------|
| `'text'` | `string` |
| `123` | `number` (integer) |
| `12.5` | `number` (float) |
| `true` / `false` | `boolean` |

## Block Comments

You can use block comments for queries with configuration:

```sql
/* QUERY complex_query :one
  result:
    count: integer not null
    email: text not null
*/
SELECT COUNT(*) as count, email FROM users GROUP BY email LIMIT 1;
```

The YAML-like configuration allows explicit type overrides when automatic inference isn't sufficient.

## Inline Comments

Regular SQL comments within queries are preserved:

```sql
-- QUERY get_active_users
SELECT * FROM users
WHERE active = true  -- Filter active users
  AND deleted_at IS NULL;  -- Exclude deleted
```

## Complex Types (DuckDB)

DuckDB supports rich data types that SQG fully maps:

### Arrays/Lists

```sql
-- QUERY get_tags :one
SELECT ['tag1', 'tag2', 'tag3'] as tags;
```

```typescript
// Generated:
{
  tags: {
    items: (string | null)[]
  } | null
}
```

### Structs

```sql
-- QUERY get_user_data :one
SELECT {'name': 'John', 'age': 30} as user;
```

```typescript
// Generated:
{
  user: {
    entries: {
      name: string | null;
      age: number | null;
    }
  } | null
}
```

### Maps

```sql
-- QUERY get_metadata :one
SELECT MAP {'key1': 'value1', 'key2': 'value2'} as meta;
```

```typescript
// Generated:
{
  meta: {
    entries: { key: string; value: string | null }[]
  } | null
}
```

### Nested Structures

```sql
-- QUERY get_complex :one
SELECT {
  'user': {'id': 1, 'name': 'John'},
  'tags': ['admin', 'user'],
  'settings': MAP {'theme': 'dark'}
} as data;
```

```typescript
// Generated:
{
  data: {
    entries: {
      user: { entries: { id: number | null; name: string | null } } | null;
      tags: { items: (string | null)[] } | null;
      settings: { entries: { key: string; value: string | null }[] } | null;
    }
  } | null
}
```

## Best Practices

### Naming Conventions

- Use `snake_case` for query names: `get_user_by_id`
- Generated code converts to `camelCase`: `getUserById`

### One Query Per Block

Each query should be in its own block:

```sql
-- QUERY get_users
SELECT * FROM users;

-- QUERY get_posts
SELECT * FROM posts;
```

### Use Meaningful Test Data

Test data helps with type inference:

```sql
-- TESTDATA
-- Include NULL values to test nullable handling
INSERT INTO users (id, name, email) VALUES
  (1, 'Test', 'test@example.com'),
  (2, 'No Email', NULL);
```

### Keep Migrations Atomic

Each migration should be a single logical change:

```sql
-- MIGRATE 1
CREATE TABLE users (id INTEGER PRIMARY KEY);

-- MIGRATE 2
ALTER TABLE users ADD COLUMN name TEXT;

-- MIGRATE 3
CREATE INDEX idx_users_name ON users(name);
```
