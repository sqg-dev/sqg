---
title: TypeScript + SQLite
description: Generate type-safe TypeScript code for SQLite using better-sqlite3
---

import { Steps } from '@astrojs/starlight/components';
import CodeExample from '@components/CodeExample.astro';
import GeneratedCode from '@components/GeneratedCode.astro';

Generate synchronous TypeScript code for SQLite databases using the [better-sqlite3](https://github.com/WiseLibs/better-sqlite3) driver.

## Overview

| Property | Value |
|----------|-------|
| Generator | `typescript/sqlite` (or `typescript/sqlite/better-sqlite3`) |
| Runtime | Node.js |
| API Style | Synchronous |
| Driver | better-sqlite3 |

## When to Use

Choose `typescript/sqlite` when:

- Building **Node.js applications** with SQLite
- Need **synchronous API** for simpler code flow
- Want **maximum performance** for single-connection scenarios


## Installation

```bash
pnpm add -D @sqg/sqg        # pnpm
npm install -D @sqg/sqg     # npm
yarn add -D @sqg/sqg        # yarn

# Install runtime dependencies
pnpm add better-sqlite3
pnpm add -D @types/better-sqlite3
```

## Example Configuration

```yaml
# sqg.yaml
version: 1
name: my-app

sql:
  - files:
      - queries.sql
    gen:
      - generator: typescript/sqlite
        output: ./src/generated/
        config:
          migrations: true  # generates applyMigrations() function
```

## Quick Start

<Steps>

1. **Initialize a project**

   ```bash
   sqg init --generator typescript/sqlite
   ```

2. **Write your SQL**

   <CodeExample id="typescript-sqlite-full" />

3. **Generate code**

   ```bash
   sqg sqg.yaml
   ```

4. **Use the generated code**

   ```typescript
   import Database from 'better-sqlite3';
   import { MyApp } from './generated/my-app';

   // Create database connection
   const db = new Database('app.db');

   // Apply migrations (with built-in tracking)
   MyApp.applyMigrations(db);

   // Create query instance
   const queries = new MyApp(db);

   // Insert data
   queries.createUser('Alice', 'alice@example.com');
   queries.createUser('Bob', 'bob@example.com');

   // Query data
   const users = queries.allUsers();
   console.log(users);
   // [{ id: 1, name: 'Alice', email: 'alice@example.com', created_at: '...' }, ...]

   const user = queries.getUser(1);
   console.log(user?.name); // 'Alice'

   // Update data
   queries.updateUser(1, 'Alice Smith');

   // Delete data
   queries.deleteUser(2);
   ```

</Steps>

## Generated Code Structure

The generator creates a single TypeScript file with:

- **Type definitions** for each query result
- **A class** with methods for each query/exec
- **Static `getMigrations()`** method returning migration SQL strings
- **Static `applyMigrations()`** method (when `config.migrations: true`) that tracks and applies migrations automatically

<GeneratedCode id="typescript-sqlite-full" title="Generated TypeScript" startMatch="allUsers(" endMatch="getUser(" />

## Transactions

Use better-sqlite3's built-in transaction support:

```typescript
const transfer = db.transaction((fromId: number, toId: number, amount: number) => {
  queries.debit(fromId, amount);
  queries.credit(toId, amount);
});

// Runs atomically
transfer(1, 2, 100);
```

## Connection Management

better-sqlite3 connections are synchronous and don't require pooling:

```typescript
// Simple single connection
const db = new Database('app.db');
const queries = new MyApp(db);

// WAL mode for better concurrency
db.pragma('journal_mode = WAL');

// Close when done
db.close();
```

## Type Mapping

| SQLite Type | TypeScript Type |
|-------------|-----------------|
| `INTEGER` | `number` |
| `REAL` | `number` |
| `TEXT` | `string` |
| `BLOB` | `Buffer` |
| `NULL` | `null` |

Nullable columns use union types: `string | null`

## Migrations

SQG generates a `getMigrations()` method that returns migration SQL strings. With `config.migrations: true`, you also get `applyMigrations()` which handles tracking automatically:

```typescript
// Recommended: built-in migration tracking
MyApp.applyMigrations(db);

// Or manual migration management
for (const migration of MyApp.getMigrations()) {
  db.exec(migration);
}
```

The built-in migration runner uses a `_sqg_migrations` table to track which migrations have been applied. Multiple sqg projects can share the same database â€” each project's migrations are tracked separately using the project name from `sqg.yaml`.

## Best Practices

1. **Use WAL mode** for better concurrent read performance
2. **Run migrations on startup** before creating the query instance
3. **Use transactions** for multiple related writes
4. **Close the database** when your application shuts down


## See Also

- [better-sqlite3 documentation](https://github.com/WiseLibs/better-sqlite3/blob/master/docs/api.md)
