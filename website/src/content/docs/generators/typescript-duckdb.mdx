---
title: TypeScript + DuckDB
description: Generate type-safe TypeScript code for DuckDB with complex type support
---

import { Steps } from '@astrojs/starlight/components';
import CodeExample from '@components/CodeExample.astro';
import GeneratedCode from '@components/GeneratedCode.astro';

Generate asynchronous TypeScript code for DuckDB databases using the
 [@duckdb/node-api](https://duckdb.org/docs/stable/clients/node_neo/overview) driver 
 (DuckDB Node.js Neo). Includes support for DuckDB's advanced types like structs, lists, and maps.

## Overview

| Property | Value |
|----------|-------|
| Generator | `typescript/duckdb` (or `typescript/duckdb/node-api`) |
| Runtime | Node.js |
| API Style | Asynchronous (async/await) |
| Driver | @duckdb/node-api |

## Installation

```bash
# Install SQG (choose one)
pnpm add -D @sqg/sqg        # pnpm
npm install -D @sqg/sqg     # npm
yarn add -D @sqg/sqg        # yarn

# Install runtime dependency
pnpm add @duckdb/node-api   # or: npm install / yarn add
```

## Example Configuration

```yaml
# sqg.yaml
version: 1
name: my-app

sql:
  - files:
      - queries.sql
    gen:
      - generator: typescript/duckdb
        output: ./src/generated/
        config:
          migrations: true  # generates applyMigrations() function
```

## Quick Start

<Steps>

1. **Initialize a project**

   ```bash
   sqg init --generator typescript/duckdb
   ```

2. **Write your SQL**

   <CodeExample id="duckdb-structs-arrays" />

3. **Generate code**

   ```bash
   sqg sqg.yaml
   ```

4. **Use the generated code**

   ```typescript
   import { DuckDBInstance } from '@duckdb/node-api';
   import { MyApp } from './generated/my-app';

   async function main() {
     // Create database connection
     const instance = await DuckDBInstance.create(':memory:');
     const connection = await instance.connect();

     // Apply migrations (with built-in tracking)
     await MyApp.applyMigrations(connection);

     // Create query instance
     const queries = new MyApp(connection);

     // Insert data
     await queries.createUser(2, 'Bob', 'bob@example.com');

     // Query data
     const users = await queries.allUsers();
     console.log(users);

     const user = await queries.getUser(1);  // Gets Alice from TESTDATA
     console.log(user?.name); // 'Alice'

     // Access complex types
     console.log(user?.metadata?.entries.role); // 'admin'
     console.log(user?.tags?.items); // ['developer', 'lead']
   }

   main();
   ```

5. **See the generated code**

   <GeneratedCode id="duckdb-structs-arrays" title="Generated TypeScript" startMatch="allUsers(" endMatch="getUser(" />

</Steps>

## Complex Types

DuckDB supports advanced types that SQG fully handles:

### Structs

SQL:
```sql
CREATE TABLE products (
  id INTEGER,
  details STRUCT(name VARCHAR, price DECIMAL(10,2), in_stock BOOLEAN)
);
```

TypeScript:
```typescript
interface DetailsStruct {
  entries: {
    name: string | null;
    price: { width: number; scale: number; value: bigint } | null;
    in_stock: boolean | null;
  };
}
```

Usage:
```typescript
const product = await queries.getProduct(1);
console.log(product?.details?.entries.name);
console.log(product?.details?.entries.price);
```

### Lists (Arrays)

SQL:
```sql
CREATE TABLE posts (
  id INTEGER,
  tags VARCHAR[],
  scores INTEGER[]
);
```

TypeScript:
```typescript
interface PostRow {
  id: number;
  tags: { items: (string | null)[] } | null;
  scores: { items: (number | null)[] } | null;
}
```

Usage:
```typescript
const post = await queries.getPost(1);
console.log(post?.tags?.items); // ['tech', 'news']
console.log(post?.scores?.items); // [95, 87, 92]
```

### Maps

SQL:
```sql
CREATE TABLE settings (
  id INTEGER,
  config MAP(VARCHAR, VARCHAR)
);
```

TypeScript:
```typescript
interface SettingsRow {
  id: number;
  config: { entries: { key: string; value: string }[] } | null;
}
```

Usage:
```typescript
const settings = await queries.getSettings(1);
for (const entry of settings?.config?.entries ?? []) {
  console.log(`${entry.key}: ${entry.value}`);
}
```

### Nested Complex Types

DuckDB supports deeply nested types:

```sql
CREATE TABLE reports (
  id INTEGER,
  data STRUCT(
    summary VARCHAR,
    metrics STRUCT(views INTEGER, clicks INTEGER)[],
    tags MAP(VARCHAR, VARCHAR[])
  )
);
```

## Type Mapping

| DuckDB Type | TypeScript Type |
|-------------|-----------------|
| `INTEGER`, `BIGINT` | `number`, `bigint` |
| `DOUBLE`, `FLOAT` | `number` |
| `VARCHAR`, `TEXT` | `string` |
| `BOOLEAN` | `boolean` |
| `TIMESTAMP` | `{ micros: bigint }` |
| `DATE` | `{ days: number }` |
| `TIME` | `{ micros: bigint }` |
| `BLOB` | `{ bytes: Uint8Array }` |
| `UUID` | `{ hugeint: bigint }` |
| `DECIMAL(p,s)` | `{ width: number; scale: number; value: bigint }` |
| `STRUCT(...)` | `{ entries: {...} }` |
| `T[]` | `{ items: T[] }` |
| `MAP(K,V)` | `{ entries: { key: K; value: V }[] }` |

## Async Pattern

All generated methods are async:

```typescript
// Query methods return Promise
const users: UserRow[] = await queries.allUsers();
const user: UserRow | undefined = await queries.getUser(1);

// Exec methods return Promise<void>
await queries.createUser(1, 'Alice', 'alice@example.com');
await queries.updateUser(1, 'Alice Smith');
```

## Connection Management

```typescript
import { DuckDBInstance } from '@duckdb/node-api';

// In-memory database
const instance = await DuckDBInstance.create(':memory:');

// File-based database
const instance = await DuckDBInstance.create('app.duckdb');

// Connect
const connection = await instance.connect();
const queries = new MyApp(connection);

// Multiple connections (for concurrent access)
const conn1 = await instance.connect();
const conn2 = await instance.connect();

// Close connections
connection.closeSync();
```

## Bulk Inserts with Appenders

DuckDB's [Appender API](https://duckdb.org/docs/data/appender) provides high-performance bulk insertsâ€”significantly faster than individual INSERT statements. SQG generates type-safe appender wrappers using the `TABLE` annotation.

### Defining an Appender

Use the `TABLE` annotation with the `:appender` modifier:

<CodeExample id="duckdb-appender" />

### Generated Code

SQG generates three components:

1. **Row interface** - Type-safe structure for each row
2. **Appender class** - Wrapper with `append()`, `appendMany()`, `flush()`, and `close()` methods
3. **Factory method** - Creates appender instances from your queries class

<GeneratedCode id="duckdb-appender" title="Generated TypeScript" startMatch="interface EventsRow" />

### Basic Usage

```typescript
// Create appender
const appender = await queries.createEventsAppender();

// Append single row
appender.append({
  id: 1,
  event_type: 'page_view',
  payload: '{"url": "/home"}',
  timestamp: null
});

// Append multiple rows
appender.appendMany([
  { id: 2, event_type: 'click', payload: null, timestamp: null },
  { id: 3, event_type: 'scroll', payload: '{"depth": 50}', timestamp: null },
]);

// Flush and close
appender.close();
```

For large datasets, call `flush()` periodically to manage memory, then `close()` when done.

### Type Mappings for Appenders

Appender row interfaces use DuckDB's native value types for temporal and binary data:

| DuckDB Column Type | TypeScript Appender Type |
|-------------------|--------------------------|
| `INTEGER`, `SMALLINT`, `TINYINT` | `number` |
| `BIGINT`, `HUGEINT` | `bigint` |
| `DOUBLE`, `FLOAT` | `number` |
| `VARCHAR`, `TEXT` | `string` |
| `BOOLEAN` | `boolean` |
| `DATE` | `DuckDBDateValue` |
| `TIME` | `DuckDBTimeValue` |
| `TIMESTAMP` | `DuckDBTimestampValue` |
| `BLOB` | `DuckDBBlobValue` |
| `UUID` | `string` |

**Note:** Nullable columns use `T | null` types.

### Working with Temporal Types

For `DATE`, `TIME`, and `TIMESTAMP` columns, use DuckDB's value constructors:

```typescript
import {
  DuckDBDateValue,
  DuckDBTimeValue,
  DuckDBTimestampValue
} from '@duckdb/node-api';

// Create timestamp value
const timestamp = DuckDBTimestampValue.fromMicros(BigInt(Date.now()) * 1000n);

// Create date value
const date = DuckDBDateValue.fromDays(Math.floor(Date.now() / 86400000));

appender.append({
  id: 1,
  event_type: 'login',
  payload: null,
  timestamp: timestamp
});
```

## Example: Analytics Query

<CodeExample id="duckdb-analytics" />

<GeneratedCode id="duckdb-analytics" title="Generated TypeScript" startMatch="async salesByRegion" />

## See Also

- [DuckDB Documentation](https://duckdb.org/docs/)
- [@duckdb/node-api (Node.js Neo)](https://duckdb.org/docs/stable/clients/node_neo/overview)
