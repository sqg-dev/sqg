// This file is generated by SQG (https://sqg.dev). Do not edit manually.
import type {
  DuckDBConnection,
  DuckDBMaterializedResult,
  DuckDBAppender,
  DuckDBDateValue,
  DuckDBTimeValue,
  DuckDBTimestampValue,
  DuckDBBlobValue,
} from "@duckdb/node-api";

export class Queries {
  constructor(private conn: DuckDBConnection) {}

  static getMigrations(): string[] {
    return [
      `CREATE TABLE events (
    id INTEGER PRIMARY KEY,
    event_type VARCHAR NOT NULL,
    payload VARCHAR,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);`,
    ];
  }

  static getQueryNames(): Map<string, keyof Queries> {
    return new Map([]);
  }

  // ==================== Appenders ====================

  async createEventsAppender(): Promise<EventsAppender> {
    return new EventsAppender(await this.conn.createAppender("events"));
  }
}

/** Row type for events appender */
export interface EventsRow {
  id: number;
  event_type: string;
  payload: string | null;
  timestamp: DuckDBTimestampValue | null;
}

/** Appender for bulk inserts into events */
export class EventsAppender {
  constructor(public readonly appender: DuckDBAppender) {}

  /** Append a single row */
  append(row: EventsRow): this {
    this.appender.appendInteger(row.id);
    this.appender.appendVarchar(row.event_type);
    if (row.payload === null || row.payload === undefined) {
      this.appender.appendNull();
    } else {
      this.appender.appendVarchar(row.payload);
    }
    if (row.timestamp === null || row.timestamp === undefined) {
      this.appender.appendNull();
    } else {
      this.appender.appendTimestamp(row.timestamp);
    }
    this.appender.endRow();
    return this;
  }

  /** Append multiple rows */
  appendMany(rows: EventsRow[]): this {
    for (const row of rows) {
      this.append(row);
    }
    return this;
  }

  /** Flush buffered data to the table */
  flush(): this {
    this.appender.flushSync();
    return this;
  }

  /** Flush and close the appender */
  close(): void {
    this.appender.closeSync();
  }
}
