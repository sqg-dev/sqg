// This file is generated by SQG (https://sqg.dev). Do not edit manually.
import type {
  DuckDBConnection,
  DuckDBMaterializedResult,
  DuckDBAppender,
  DuckDBDateValue,
  DuckDBTimeValue,
  DuckDBTimestampValue,
  DuckDBBlobValue,
} from "@duckdb/node-api";

export class Queries {
  constructor(private conn: DuckDBConnection) {}

  static getMigrations(): string[] {
    return [
      `CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  tags TEXT[],
  metadata STRUCT(
    price DOUBLE,
    category TEXT,
    in_stock BOOLEAN
  )
);`,
    ];
  }

  static getQueryNames(): Map<string, keyof Queries> {
    return new Map([
      ["all_products", "allProducts"],
      ["products_by_category", "productsByCategory"],
    ]);
  }

  async allProducts(): Promise<
    {
      id: number | null;
      name: string | null;
      tags: { items: (string | null)[] };
      metadata: {
        entries: {
          price: number | null;
          category: string | null;
          in_stock: boolean | null;
        };
      };
    }[]
  > {
    const sql = "SELECT * FROM products;";
    const reader = await this.conn.runAndReadAll(sql, []);
    return reader.getRowObjects() as {
      id: number | null;
      name: string | null;
      tags: { items: (string | null)[] };
      metadata: {
        entries: {
          price: number | null;
          category: string | null;
          in_stock: boolean | null;
        };
      };
    }[];
  }

  async productsByCategory(
    category: string,
  ): Promise<
    {
      id: number | null;
      name: string | null;
      tags: { items: (string | null)[] };
      metadata: {
        entries: {
          price: number | null;
          category: string | null;
          in_stock: boolean | null;
        };
      };
    }[]
  > {
    const sql = "SELECT * FROM products WHERE metadata.category =?;";
    const reader = await this.conn.runAndReadAll(sql, [category]);
    return reader.getRowObjects() as {
      id: number | null;
      name: string | null;
      tags: { items: (string | null)[] };
      metadata: {
        entries: {
          price: number | null;
          category: string | null;
          in_stock: boolean | null;
        };
      };
    }[];
  }

  // ==================== Appenders ====================

  async createProductsAppender(): Promise<ProductsAppender> {
    return new ProductsAppender(await this.conn.createAppender("products"));
  }
}

/** Row type for products appender */
export interface ProductsRow {
  id: number;
  name: string;
  tags: string | null;
  metadata: string | null;
}

/** Appender for bulk inserts into products */
export class ProductsAppender {
  constructor(public readonly appender: DuckDBAppender) {}

  /** Append a single row */
  append(row: ProductsRow): this {
    this.appender.appendInteger(row.id);
    this.appender.appendVarchar(row.name);
    if (row.tags === null || row.tags === undefined) {
      this.appender.appendNull();
    } else {
      this.appender.appendVarchar(row.tags);
    }
    if (row.metadata === null || row.metadata === undefined) {
      this.appender.appendNull();
    } else {
      this.appender.appendVarchar(row.metadata);
    }
    this.appender.endRow();
    return this;
  }

  /** Append multiple rows */
  appendMany(rows: ProductsRow[]): this {
    for (const row of rows) {
      this.append(row);
    }
    return this;
  }

  /** Flush buffered data to the table */
  flush(): this {
    this.appender.flushSync();
    return this;
  }

  /** Flush and close the appender */
  close(): void {
    this.appender.closeSync();
  }
}
