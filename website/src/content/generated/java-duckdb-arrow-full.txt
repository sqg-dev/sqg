// This file is generated by SQG (https://sqg.dev). Do not edit manually.
package generated;

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import org.apache.arrow.memory.RootAllocator;
import org.apache.arrow.vector.*;
import org.apache.arrow.vector.complex.ListVector;
import org.apache.arrow.vector.ipc.ArrowReader;
import org.duckdb.DuckDBConnection;
import org.duckdb.DuckDBResultSet;
import generated.QueriesJdbc.*;

public class Queries {
    private final DuckDBConnection connection;
    private final QueriesJdbc jdbc;

    public Queries(DuckDBConnection connection) {
        this.connection = connection;
        this.jdbc = new QueriesJdbc(connection);
    }


    public static List<String> getMigrations() {   
        return QueriesJdbc.getMigrations();
    }

    public record EventsByUserResult(PreparedStatement statement, RootAllocator allocator, ArrowReader reader,
    IntVector id, IntVector user_id, VarCharVector event_type, Result properties, List&lt;String&gt; tags, Object timestamp) implements AutoCloseable {
        public boolean loadNextBatch() throws IOException {
            return reader.loadNextBatch();
        }
        
        public int getRowCount() throws IOException {
            return reader.getVectorSchemaRoot().getRowCount();
        }
    
        public void close() throws IOException, SQLException {
            reader.close();
            allocator.close();
            statement.close();
        }
    }
    public EventsByUserResult eventsByUser(Integer user_id) throws SQLException, IOException {
        var stmt = connection.prepareStatement("""
SELECT * FROM events WHERE user_id =? ORDER BY timestamp DESC;""");
    stmt.setObject(1, user_id);
        var rs = (DuckDBResultSet) stmt.executeQuery();
        var allocator = new RootAllocator();
        var reader = (ArrowReader) rs.arrowExportStream(allocator, 65536);
        var root = reader.getVectorSchemaRoot();
        
        return new EventsByUserResult(stmt, allocator, reader, (IntVector)root.getVector("id"), (IntVector)root.getVector("user_id"), (VarCharVector)root.getVector("event_type"), (Result)root.getVector("properties"), (List&lt;String&gt;)root.getVector("tags"), (Object)root.getVector("timestamp"));
        
    }
    public record EventCountsResult(PreparedStatement statement, RootAllocator allocator, ArrowReader reader,
    VarCharVector event_type, Object count) implements AutoCloseable {
        public boolean loadNextBatch() throws IOException {
            return reader.loadNextBatch();
        }
        
        public int getRowCount() throws IOException {
            return reader.getVectorSchemaRoot().getRowCount();
        }
    
        public void close() throws IOException, SQLException {
            reader.close();
            allocator.close();
            statement.close();
        }
    }
    public EventCountsResult eventCounts() throws SQLException, IOException {
        var stmt = connection.prepareStatement("""
SELECT event_type, COUNT(*) as count
FROM events
GROUP BY event_type
ORDER BY count DESC;""");
        var rs = (DuckDBResultSet) stmt.executeQuery();
        var allocator = new RootAllocator();
        var reader = (ArrowReader) rs.arrowExportStream(allocator, 65536);
        var root = reader.getVectorSchemaRoot();
        
        return new EventCountsResult(stmt, allocator, reader, (VarCharVector)root.getVector("event_type"), (Object)root.getVector("count"));
        
    }
    public record EventsWithTagResult(PreparedStatement statement, RootAllocator allocator, ArrowReader reader,
    IntVector id, IntVector user_id, VarCharVector event_type, Result properties, List&lt;String&gt; tags, Object timestamp) implements AutoCloseable {
        public boolean loadNextBatch() throws IOException {
            return reader.loadNextBatch();
        }
        
        public int getRowCount() throws IOException {
            return reader.getVectorSchemaRoot().getRowCount();
        }
    
        public void close() throws IOException, SQLException {
            reader.close();
            allocator.close();
            statement.close();
        }
    }
    public EventsWithTagResult eventsWithTag(String tag) throws SQLException, IOException {
        var stmt = connection.prepareStatement("""
SELECT * FROM events WHERE list_contains(tags, ?);""");
    stmt.setObject(1, tag);
        var rs = (DuckDBResultSet) stmt.executeQuery();
        var allocator = new RootAllocator();
        var reader = (ArrowReader) rs.arrowExportStream(allocator, 65536);
        var root = reader.getVectorSchemaRoot();
        
        return new EventsWithTagResult(stmt, allocator, reader, (IntVector)root.getVector("id"), (IntVector)root.getVector("user_id"), (VarCharVector)root.getVector("event_type"), (Result)root.getVector("properties"), (List&lt;String&gt;)root.getVector("tags"), (Object)root.getVector("timestamp"));
        
    }

}



